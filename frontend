from flask import Flask, request, render_template_string, Response
from sqlalchemy import create_engine, text
import os
import csv
import io

app = Flask(__name__)
engine = create_engine(os.environ["PG_DSN"])

TABLE = "option_chain_eod"

# IMPORTANT: column names MUST be lowercase (Postgres folds identifiers)
COLUMNS = [
    "symbol",
    "quotedate",
    "underlyinglast",
    "expiredate",
    "strike",
    "dte",

    "callsymbol",
    "callvolume",
    "callbid",
    "callask",
    "callmid",

    "putsymbol",
    "putvolume",
    "putbid",
    "putask",
    "putmid",

    "itmperccalls",
    "itmpercputs",
]

TEMPLATE = """
<!doctype html>
<title>Options DB</title>
<h2>Database Table: {{ table }}</h2>

<form method="get">
<table border="1" cellpadding="4" cellspacing="0">
  <tr>
    {% for col in columns %}
      <th>
        {{ col }}<br>
        <input type="text" name="f_{{ col }}" value="{{ filters.get(col,'') }}" size="10"><br>
        <select name="s_{{ col }}">
          <option value="">—</option>
          <option value="asc" {% if sorts.get(col)=='asc' %}selected{% endif %}>▲</option>
          <option value="desc" {% if sorts.get(col)=='desc' %}selected{% endif %}>▼</option>
        </select>
      </th>
    {% endfor %}
  </tr>
</table>

<br>
Rows:
<input type="number" name="limit" value="{{ limit }}" min="1" max="50000">

<button type="submit" name="format" value="html">Run</button>
<button type="submit" name="format" value="csv">Download CSV</button>
</form>

<hr>

<h3>Results</h3>

<table border="1" cellpadding="4" cellspacing="0">
  <tr>
    {% for col in columns %}
      <th>{{ col }}</th>
    {% endfor %}
  </tr>

  {% for row in rows %}
    <tr>
      {% for col in columns %}
        <td>{{ row.get(col) }}</td>
      {% endfor %}
    </tr>
  {% endfor %}
</table>
"""

@app.route("/", methods=["GET"])
def index():
    filters = {}
    sorts = {}
    where_clauses = []
    params = {}

    for col in COLUMNS:
        fval = request.args.get(f"f_{col}")
        sval = request.args.get(f"s_{col}")

        if fval:
            filters[col] = fval
            where_clauses.append(f"{col}::text ILIKE :f_{col}")
            params[f"f_{col}"] = f"%{fval}%"

        if sval in ("asc", "desc"):
            sorts[col] = sval

    where_sql = ""
    if where_clauses:
        where_sql = "WHERE " + " AND ".join(where_clauses)

    if sorts:
        order_parts = [f"{col} {direction}" for col, direction in sorts.items()]
        order_sql = "ORDER BY " + ", ".join(order_parts)
    else:
        order_sql = "ORDER BY quotedate DESC, symbol ASC, expiredate ASC, strike ASC"

    limit = int(request.args.get("limit", 100))
    params["limit"] = limit

    sql = f"""
    SELECT {",".join(COLUMNS)}
    FROM {TABLE}
    {where_sql}
    {order_sql}
    LIMIT :limit
    """

    with engine.connect() as conn:
        result = conn.execute(text(sql), params)
        rows = [dict(r._mapping) for r in result]

    # ─────────────────────────────
    # CSV DOWNLOAD
    # ─────────────────────────────
    if request.args.get("format") == "csv":
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=COLUMNS)
        writer.writeheader()
        writer.writerows(rows)

        return Response(
            output.getvalue(),
            mimetype="text/csv",
            headers={
                "Content-Disposition": "attachment; filename=options_export.csv"
            },
        )

    return render_template_string(
        TEMPLATE,
        rows=rows,
        columns=COLUMNS,
        filters=filters,
        sorts=sorts,
        limit=limit,
        table=TABLE,
    )

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
