import os
import time
import logging
import json
import requests
from datetime import date, datetime

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ============================
# CONFIG
# ============================
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]
BASE_URL = "https://api.tradier.com/v1"

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

DEBUG_DUMP_TRADIER_JSON = True

# ============================
# LOGGING
# ============================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger("EOD")

# ============================
# HTTP
# ============================
session = requests.Session()
session.headers.update({
    "Authorization": f"Bearer {TRADIER_TOKEN}",
    "Accept": "application/json",
})

def tradier_get(path, params):
    r = session.get(f"{BASE_URL}{path}", params=params, timeout=30)
    r.raise_for_status()
    j = r.json()
    if DEBUG_DUMP_TRADIER_JSON:
        print("\n" + "="*80)
        print(f"DEBUG {path} {params}")
        print(json.dumps(j, indent=2))
        print("="*80)
    return j

# ============================
# DB
# ============================
engine = create_engine(PG_DSN, pool_pre_ping=True)

def ensure_schema():
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        symbol TEXT NOT NULL,
        quoteDate DATE NOT NULL,
        underlyingLast NUMERIC,
        expireDate DATE NOT NULL,
        strike NUMERIC NOT NULL,

        callSymbol TEXT,
        callVolume BIGINT,
        callBid NUMERIC,
        callAsk NUMERIC,
        callMid NUMERIC,

        putSymbol TEXT,
        putVolume BIGINT,
        putBid NUMERIC,
        putAsk NUMERIC,
        putMid NUMERIC,

        itmPercCalls NUMERIC,
        itmPercPuts NUMERIC,
        dte INTEGER,

        PRIMARY KEY (quoteDate, symbol, expireDate, strike)
    );
    """
    with engine.begin() as c:
        c.execute(text(ddl))

def upsert(rows):
    if not rows:
        return
    cols = list(rows[0].keys())
    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT (quoteDate, symbol, expireDate, strike)
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in cols if c not in ("quoteDate","symbol","expireDate","strike"))
    with engine.begin() as conn:
        execute_values(conn.connection.cursor(), sql, [tuple(r[c] for c in cols) for r in rows])

# ============================
# MAIN
# ============================
def run():
    ensure_schema()
    today = date.today()

    for ticker in TICKERS:
        expirations = tradier_get(
            "/markets/options/expirations",
            {"symbol": ticker, "includeAllRoots": "true"}
        )["expirations"]["date"]

        for exp in expirations:
            chain = tradier_get(
                "/markets/options/chains",
                {"symbol": ticker, "expiration": exp, "greeks": "false"}
            )["options"]["option"]

            # ---- FIX 1: get underlying_last ONCE
            underlying_last = None
            for o in chain:
                if o.get("underlying_last") is not None:
                    underlying_last = o["underlying_last"]
                    break

            # ---- FIX 2: normalize strikes to INT (x1000)
            calls = {}
            puts = {}

            for o in chain:
                strike_i = int(round(float(o["strike"]) * 1000))
                if o["option_type"] == "call":
                    calls[strike_i] = o
                else:
                    puts[strike_i] = o

            rows = []
            for strike_i in set(calls) | set(puts):
                strike = strike_i / 1000

                call = calls.get(strike_i, {})
                put  = puts.get(strike_i, {})

                cb, ca = call.get("bid"), call.get("ask")
                pb, pa = put.get("bid"), put.get("ask")

                rows.append({
                    "symbol": ticker,
                    "quoteDate": today,
                    "underlyingLast": underlying_last,
                    "expireDate": exp,
                    "strike": strike,

                    "callSymbol": call.get("symbol"),
                    "callVolume": call.get("volume"),
                    "callBid": cb,
                    "callAsk": ca,
                    "callMid": (cb+ca)/2 if cb is not None and ca is not None else None,

                    "putSymbol": put.get("symbol"),
                    "putVolume": put.get("volume"),
                    "putBid": pb,
                    "putAsk": pa,
                    "putMid": (pb+pa)/2 if pb is not None and pa is not None else None,

                    "itmPercCalls": ((underlying_last-strike)/strike)*100 if underlying_last else None,
                    "itmPercPuts": None,
                    "dte": (date.fromisoformat(exp) - today).days,
                })

            upsert(rows)
            log.info("%s %s inserted %d rows", ticker, exp, len(rows))
            time.sleep(1)

    log.info("DONE")

if __name__ == "__main__":
    run()

