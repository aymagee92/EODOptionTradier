import os
import time
import logging
import requests
from datetime import date

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ----------------------------
# LOGGING (VERBOSE)
# ----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger(__name__)

# ----------------------------
# CONFIG
# ----------------------------
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

TICKERS_PER_BATCH = 10
SLEEP_BETWEEN_BATCH_SECONDS = 10

# REAL / LIVE ONLY (no sandbox)
BASE_URL = "https://api.tradier.com/v1"

HEADERS = {
    "Authorization": "Bearer {}".format(TRADIER_TOKEN),
    "Accept": "application/json",
}

# Quotes batching: keep reasonable to avoid URL length / server limits
QUOTES_SYMBOLS_PER_CALL = 50

session = requests.Session()
session.headers.update(HEADERS)

# ----------------------------
# TRADIER HELPERS
# ----------------------------
def tradier_get(path: str, params: dict | None = None) -> dict:
    url = f"{BASE_URL}{path}"
    r = session.get(url, params=params, timeout=30)

    # Log useful error details
    if r.status_code >= 400:
        log.error(
            "Tradier error %s %s params=%s body=%s",
            r.status_code,
            url,
            params,
            r.text[:2000],
        )

    r.raise_for_status()
    return r.json()


def get_expirations(ticker: str) -> list[str]:
    j = tradier_get(
        "/markets/options/expirations",
        params={"symbol": ticker, "includeAllRoots": "true", "strikes": "false"},
    )
    dates = (j.get("expirations") or {}).get("date", [])
    if isinstance(dates, str):
        dates = [dates]
    return dates


def get_chain(ticker: str, expiration: str) -> list[dict]:
    j = tradier_get(
        "/markets/options/chains",
        params={"symbol": ticker, "expiration": expiration, "greeks": "false"},
    )
    options = (j.get("options") or {}).get("option", [])
    if isinstance(options, dict):
        options = [options]
    if options is None:
        options = []
    return options


def chunked(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def get_quotes_map(symbols: list[str]) -> dict[str, dict]:
    """
    Calls /markets/quotes and returns a dict: { symbol: quote_dict }.
    Handles Tradier's "single dict vs list" response shape.
    """
    quotes_by_symbol: dict[str, dict] = {}

    # Dedup + remove empties while preserving order
    seen = set()
    clean = []
    for s in symbols:
        if not s:
            continue
        if s in seen:
            continue
        seen.add(s)
        clean.append(s)

    for batch in chunked(clean, QUOTES_SYMBOLS_PER_CALL):
        j = tradier_get(
            "/markets/quotes",
            params={"symbols": ",".join(batch), "greeks": "false"},
        )

        q = ((j.get("quotes") or {}).get("quote")) if isinstance(j, dict) else None
        if q is None:
            continue

        if isinstance(q, dict):
            q = [q]

        for item in q:
            sym = item.get("symbol")
            if sym:
                quotes_by_symbol[sym] = item

    return quotes_by_symbol


# ----------------------------
# POSTGRES
# ----------------------------
def get_engine():
    return create_engine(PG_DSN, pool_pre_ping=True)


def ensure_schema(engine):
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        quoteDate        DATE NOT NULL,
        symbol           TEXT NOT NULL,

        underlyingLast   NUMERIC,
        expireDate       DATE NOT NULL,
        strike           NUMERIC NOT NULL,

        callVolume       BIGINT,
        callBid          NUMERIC,
        callAsk          NUMERIC,
        callMid          NUMERIC,

        putVolume        BIGINT,
        putBid           NUMERIC,
        putAsk           NUMERIC,
        putMid           NUMERIC,

        itmPercCalls     NUMERIC,
        itmPercPuts      NUMERIC,
        dte              INTEGER,

        PRIMARY KEY (quoteDate, symbol, expireDate, strike)
    );
    """
    with engine.begin() as conn:
        conn.execute(text(ddl))


def upsert_rows(engine, rows: list[dict]):
    if not rows:
        return

    cols = list(rows[0].keys())
    tuples = [tuple(r.get(c) for c in cols) for r in rows]

    conflict_cols = ("quoteDate", "symbol", "expireDate", "strike")
    update_cols = [c for c in cols if c not in conflict_cols]

    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT ({",".join(conflict_cols)})
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in update_cols)

    with engine.begin() as conn:
        raw = conn.connection
        with raw.cursor() as cur:
            execute_values(cur, sql, tuples, page_size=1000)


# ----------------------------
# MAIN
# ----------------------------
def run_eod():
    log.info("EOD RUN START | base_url=%s", BASE_URL)

    engine = get_engine()
    ensure_schema(engine)

    run_date = date.today()

    for batch_num, tickers_batch in enumerate(chunked(TICKERS, TICKERS_PER_BATCH), start=1):
        log.info("Batch %s: %s", batch_num, tickers_batch)

        for ticker in tickers_batch:
            try:
                expirations = get_expirations(ticker)
                if not expirations:
                    log.warning("%s: no expirations returned", ticker)
                    continue

                for exp in expirations:
                    exp_date = date.fromisoformat(exp)
                    dte = (exp_date - run_date).days

                    chain = get_chain(ticker, exp)
                    if not chain:
                        log.warning("%s %s: empty chain", ticker, exp)
                        continue

                    # Build strike->contract dicts AND capture option symbols for quotes
                    calls_by_strike: dict[float, dict] = {}
                    puts_by_strike: dict[float, dict] = {}
                    call_sym_by_strike: dict[float, str] = {}
                    put_sym_by_strike: dict[float, str] = {}

                    option_symbols: list[str] = []
                    for o in chain:
                        strike = o.get("strike")
                        if strike is None:
                            continue

                        ot = o.get("option_type")
                        sym = o.get("symbol")  # OCC option symbol

                        if ot == "call":
                            calls_by_strike[strike] = o
                            if sym:
                                call_sym_by_strike[strike] = sym
                                option_symbols.append(sym)
                        elif ot == "put":
                            puts_by_strike[strike] = o
                            if sym:
                                put_sym_by_strike[strike] = sym
                                option_symbols.append(sym)

                    # Fetch quotes for underlying + all options in this expiration
                    # This is the key fix: bid/ask/volume/last come from quotes reliably.
                    quotes_map = get_quotes_map([ticker] + option_symbols)

                    underlying_quote = quotes_map.get(ticker, {}) or {}
                    underlying_last = underlying_quote.get("last")

                    rows = []
                    for strike in set(calls_by_strike) | set(puts_by_strike):
                        call_contract = calls_by_strike.get(strike, {}) or {}
                        put_contract = puts_by_strike.get(strike, {}) or {}

                        call_sym = call_sym_by_strike.get(strike)
                        put_sym = put_sym_by_strike.get(strike)

                        call_q = quotes_map.get(call_sym, {}) if call_sym else {}
                        put_q = quotes_map.get(put_sym, {}) if put_sym else {}

                        # Prefer quote fields; fall back to chain fields if present
                        callBid = call_q.get("bid", call_contract.get("bid"))
                        callAsk = call_q.get("ask", call_contract.get("ask"))
                        putBid = put_q.get("bid", put_contract.get("bid"))
                        putAsk = put_q.get("ask", put_contract.get("ask"))

                        callVol = call_q.get("volume", call_contract.get("volume"))
                        putVol = put_q.get("volume", put_contract.get("volume"))

                        callMid = (callBid + callAsk) / 2 if callBid is not None and callAsk is not None else None
                        putMid = (putBid + putAsk) / 2 if putBid is not None and putAsk is not None else None

                        itmPercCalls = (
                            ((underlying_last - strike) / strike) * 100
                            if underlying_last not in (None, 0) and strike not in (None, 0)
                            else None
                        )
                        itmPercPuts = (-itmPercCalls) if itmPercCalls is not None else None

                        rows.append({
                            "quoteDate": run_date,
                            "symbol": ticker,

                            "underlyingLast": underlying_last,
                            "expireDate": exp_date,
                            "strike": strike,

                            "callVolume": callVol,
                            "callBid": callBid,
                            "callAsk": callAsk,
                            "callMid": callMid,

                            "putVolume": putVol,
                            "putBid": putBid,
                            "putAsk": putAsk,
                            "putMid": putMid,

                            "itmPercCalls": itmPercCalls,
                            "itmPercPuts": itmPercPuts,
                            "dte": dte,
                        })

                    upsert_rows(engine, rows)
                    log.info("%s %s: saved %s rows", ticker, exp, len(rows))

            except Exception as e:
                log.exception("%s: failed in ticker loop: %s", ticker, e)

        time.sleep(SLEEP_BETWEEN_BATCH_SECONDS)

    log.info("EOD RUN COMPLETE")


if __name__ == "__main__":
    run_eod()

