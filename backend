import os
import time
import logging
import json
import requests
from datetime import date, datetime

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ----------------------------
# LOGGING (VERBOSE)
# ----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger(__name__)

# ----------------------------
# CONFIG
# ----------------------------
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

TICKERS_PER_BATCH = 10
SLEEP_BETWEEN_BATCH_SECONDS = 10

# LIVE ONLY
BASE_URL = "https://api.tradier.com/v1"

HEADERS = {
    "Authorization": "Bearer {}".format(TRADIER_TOKEN),
    "Accept": "application/json",
}

session = requests.Session()
session.headers.update(HEADERS)

# Turn this on/off to dump raw JSON to terminal
DEBUG_DUMP_TRADIER_JSON = True


# ----------------------------
# DEBUG PRINT
# ----------------------------
def debug_print_tradier_response(label: str, payload: dict):
    if not DEBUG_DUMP_TRADIER_JSON:
        return
    print("\n" + "=" * 100)
    print(f"DEBUG: {label}")
    print("=" * 100)
    print(json.dumps(payload, indent=2))
    print("=" * 100 + "\n")


# ----------------------------
# TRADIER HELPERS
# ----------------------------
def tradier_get(path: str, params: dict | None = None) -> dict:
    url = f"{BASE_URL}{path}"
    r = session.get(url, params=params, timeout=30)

    # Helpful diagnostics on errors
    if r.status_code >= 400:
        log.error("Tradier error %s %s params=%s body=%s", r.status_code, url, params, r.text[:2000])

    r.raise_for_status()
    j = r.json()

    # Optional: dump ALL responses
    if DEBUG_DUMP_TRADIER_JSON:
        debug_print_tradier_response(f"GET {path} params={params}", j)

    return j


def get_expirations(ticker: str) -> list[str]:
    j = tradier_get(
        "/markets/options/expirations",
        params={"symbol": ticker, "includeAllRoots": "true", "strikes": "false"},
    )
    dates = (j.get("expirations") or {}).get("date", [])
    if isinstance(dates, str):
        dates = [dates]
    return dates


def get_chain(ticker: str, expiration: str) -> list[dict]:
    j = tradier_get(
        "/markets/options/chains",
        params={"symbol": ticker, "expiration": expiration, "greeks": "false"},
    )
    options = (j.get("options") or {}).get("option", [])
    if isinstance(options, dict):
        options = [options]
    if options is None:
        options = []
    return options


def chunked(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def build_occ_symbol(underlying: str, expiration_iso: str, cp: str, strike: float) -> str:
    """
    Build OCC symbol like: AAPL260206C00257500
    underlying + YYMMDD + C/P + strike*1000 padded to 8 digits
    """
    dt = datetime.strptime(expiration_iso, "%Y-%m-%d").date()
    yymmdd = dt.strftime("%y%m%d")
    strike_int = int(round(float(strike) * 1000))
    return f"{underlying}{yymmdd}{cp}{strike_int:08d}"


# ----------------------------
# POSTGRES
# ----------------------------
def get_engine():
    return create_engine(PG_DSN, pool_pre_ping=True)


def ensure_schema(engine):
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        symbol           TEXT NOT NULL,      -- underlying (AAPL)
        quoteDate        DATE NOT NULL,
        underlyingLast   NUMERIC,
        expireDate       DATE NOT NULL,
        strike           NUMERIC NOT NULL,

        callSymbol       TEXT,
        callVolume       BIGINT,
        callBid          NUMERIC,
        callAsk          NUMERIC,
        callMid          NUMERIC,

        putSymbol        TEXT,
        putVolume        BIGINT,
        putBid           NUMERIC,
        putAsk           NUMERIC,
        putMid           NUMERIC,

        itmPercCalls     NUMERIC,
        itmPercPuts      NUMERIC,
        dte              INTEGER,

        PRIMARY KEY (quoteDate, symbol, expireDate, strike)
    );
    """
    with engine.begin() as conn:
        conn.execute(text(ddl))


def upsert_rows(engine, rows: list[dict]):
    if not rows:
        return

    cols = list(rows[0].keys())
    tuples = [tuple(r.get(c) for c in cols) for r in rows]

    conflict_cols = ("quoteDate", "symbol", "expireDate", "strike")
    update_cols = [c for c in cols if c not in conflict_cols]

    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT ({",".join(conflict_cols)})
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in update_cols)

    with engine.begin() as conn:
        raw = conn.connection
        with raw.cursor() as cur:
            execute_values(cur, sql, tuples, page_size=1000)


# ----------------------------
# MAIN
# ----------------------------
def run_eod():
    log.info("EOD RUN START | base_url=%s", BASE_URL)

    engine = get_engine()
    ensure_schema(engine)

    run_date = date.today()

    for batch_num, tickers_batch in enumerate(chunked(TICKERS, TICKERS_PER_BATCH), start=1):
        log.info("Batch %s: %s", batch_num, tickers_batch)

        for ticker in tickers_batch:
            try:
                expirations = get_expirations(ticker)
                if not expirations:
                    log.warning("%s: no expirations returned", ticker)
                    continue

                for exp in expirations:
                    exp_date = date.fromisoformat(exp)
                    dte = (exp_date - run_date).days

                    chain = get_chain(ticker, exp)
                    if not chain:
                        log.warning("%s %s: empty chain", ticker, exp)
                        continue

                    # strikes found in chain
                    strikes = set()
                    for o in chain:
                        s = o.get("strike")
                        if s is not None:
                            strikes.add(float(s))

                    if not strikes:
                        log.warning("%s %s: no strikes in chain", ticker, exp)
                        continue

                    # Build OCC symbols for reference/debugging/storage
                    call_symbols = {s: build_occ_symbol(ticker, exp, "C", s) for s in strikes}
                    put_symbols  = {s: build_occ_symbol(ticker, exp, "P", s) for s in strikes}

                    # Build maps from the CHAIN response itself (since you confirmed it includes bid/ask after hours)
                    calls_by_strike = {}
                    puts_by_strike = {}
                    underlying_last = None

                    for o in chain:
                        if underlying_last is None:
                            underlying_last = o.get("underlying_last") or o.get("underlyingLast")

                        strike = o.get("strike")
                        if strike is None:
                            continue
                        strike = float(strike)

                        ot = o.get("option_type")
                        if ot == "call":
                            calls_by_strike[strike] = o
                        elif ot == "put":
                            puts_by_strike[strike] = o

                    rows = []
                    for strike in strikes:
                        call = calls_by_strike.get(strike, {}) or {}
                        put  = puts_by_strike.get(strike, {}) or {}

                        callBid = call.get("bid")
                        callAsk = call.get("ask")
                        putBid  = put.get("bid")
                        putAsk  = put.get("ask")

                        callMid = (callBid + callAsk) / 2 if callBid is not None and callAsk is not None else None
                        putMid  = (putBid + putAsk) / 2 if putBid is not None and putAsk is not None else None

                        itmPercCalls = (
                            ((underlying_last - strike) / strike) * 100
                            if underlying_last not in (None, 0) and strike not in (None, 0)
                            else None
                        )
                        itmPercPuts = (-itmPercCalls) if itmPercCalls is not None else None

                        rows.append({
                            "symbol": ticker,
                            "quoteDate": run_date,
                            "underlyingLast": underlying_last,
                            "expireDate": exp_date,
                            "strike": strike,

                            "callSymbol": call_symbols[strike],
                            "callVolume": call.get("volume"),
                            "callBid": callBid,
                            "callAsk": callAsk,
                            "callMid": callMid,

                            "putSymbol": put_symbols[strike],
                            "putVolume": put.get("volume"),
                            "putBid": putBid,
                            "putAsk": putAsk,
                            "putMid": putMid,

                            "itmPercCalls": itmPercCalls,
                            "itmPercPuts": itmPercPuts,
                            "dte": dte,
                        })

                    upsert_rows(engine, rows)
                    log.info("%s %s: saved %s rows", ticker, exp, len(rows))

            except Exception as e:
                log.exception("%s: failed in ticker loop: %s", ticker, e)

        time.sleep(SLEEP_BETWEEN_BATCH_SECONDS)

    log.info("EOD RUN COMPLETE")


if __name__ == "__main__":
    run_eod()

