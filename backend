import os
import time
import logging
import requests
from datetime import date, datetime

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ----------------------------
# LOGGING (VERBOSE)
# ----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger(__name__)

# ----------------------------
# CONFIG
# ----------------------------
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

TICKERS_PER_BATCH = 10
SLEEP_BETWEEN_BATCH_SECONDS = 10

# LIVE ONLY
BASE_URL = "https://api.tradier.com/v1"

HEADERS = {
    "Authorization": "Bearer {}".format(TRADIER_TOKEN),
    "Accept": "application/json",
}

QUOTES_SYMBOLS_PER_CALL = 50

session = requests.Session()
session.headers.update(HEADERS)

# ----------------------------
# TRADIER HELPERS
# ----------------------------
def tradier_get(path: str, params: dict | None = None) -> dict:
    url = f"{BASE_URL}{path}"
    r = session.get(url, params=params, timeout=30)

    if r.status_code >= 400:
        log.error(
            "Tradier error %s %s params=%s body=%s",
            r.status_code, url, params, r.text[:2000]
        )

    r.raise_for_status()
    return r.json()


def get_expirations(ticker: str) -> list[str]:
    j = tradier_get(
        "/markets/options/expirations",
        params={"symbol": ticker, "includeAllRoots": "true", "strikes": "false"},
    )
    dates = (j.get("expirations") or {}).get("date", [])
    if isinstance(dates, str):
        dates = [dates]
    return dates


def get_chain(ticker: str, expiration: str) -> list[dict]:
    j = tradier_get(
        "/markets/options/chains",
        params={"symbol": ticker, "expiration": expiration, "greeks": "false"},
    )
    options = (j.get("options") or {}).get("option", [])
    if isinstance(options, dict):
        options = [options]
    if options is None:
        options = []
    return options


def chunked(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def build_occ_symbol(underlying: str, expiration_iso: str, cp: str, strike: float) -> str:
    """
    Build OCC symbol like: AAPL260206C00257500
    underlying: AAPL
    expiration_iso: 2026-02-06 -> 260206
    cp: 'C' or 'P'
    strike: 257.5 -> 257500 -> '00257500' (strike*1000, padded to 8 digits)
    """
    dt = datetime.strptime(expiration_iso, "%Y-%m-%d").date()
    yymmdd = dt.strftime("%y%m%d")
    strike_int = int(round(float(strike) * 1000))
    return f"{underlying}{yymmdd}{cp}{strike_int:08d}"


def get_quotes_map(symbols: list[str]) -> dict[str, dict]:
    """
    GET /markets/quotes?symbols=...
    Returns map: symbol -> quote dict
    Handles single dict vs list response.
    """
    quotes_by_symbol: dict[str, dict] = {}

    # dedupe preserve order
    seen = set()
    clean = []
    for s in symbols:
        if not s:
            continue
        if s in seen:
            continue
        seen.add(s)
        clean.append(s)

    for batch in chunked(clean, QUOTES_SYMBOLS_PER_CALL):
        j = tradier_get(
            "/markets/quotes",
            params={"symbols": ",".join(batch), "greeks": "false"},
        )

        q = (j.get("quotes") or {}).get("quote")
        if q is None:
            continue
        if isinstance(q, dict):
            q = [q]

        for item in q:
            sym = item.get("symbol")
            if sym:
                quotes_by_symbol[sym] = item

    return quotes_by_symbol


# ----------------------------
# POSTGRES
# ----------------------------
def get_engine():
    return create_engine(PG_DSN, pool_pre_ping=True)


def ensure_schema(engine):
    # symbol FIRST column, and call/put on same row
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        symbol           TEXT NOT NULL,      -- underlying (AAPL)
        quoteDate        DATE NOT NULL,
        expireDate       DATE NOT NULL,
        strike           NUMERIC NOT NULL,

        underlyingLast   NUMERIC,

        callSymbol       TEXT,
        callVolume       BIGINT,
        callBid          NUMERIC,
        callAsk          NUMERIC,
        callMid          NUMERIC,

        putSymbol        TEXT,
        putVolume        BIGINT,
        putBid           NUMERIC,
        putAsk           NUMERIC,
        putMid           NUMERIC,

        itmPercCalls     NUMERIC,
        itmPercPuts      NUMERIC,
        dte              INTEGER,

        PRIMARY KEY (quoteDate, symbol, expireDate, strike)
    );
    """
    with engine.begin() as conn:
        conn.execute(text(ddl))


def upsert_rows(engine, rows: list[dict]):
    if not rows:
        return

    cols = list(rows[0].keys())
    tuples = [tuple(r.get(c) for c in cols) for r in rows]

    conflict_cols = ("quoteDate", "symbol", "expireDate", "strike")
    update_cols = [c for c in cols if c not in conflict_cols]

    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT ({",".join(conflict_cols)})
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in update_cols)

    with engine.begin() as conn:
        raw = conn.connection
        with raw.cursor() as cur:
            execute_values(cur, sql, tuples, page_size=1000)


# ----------------------------
# MAIN
# ----------------------------
def run_eod():
    log.info("EOD RUN START | base_url=%s", BASE_URL)

    engine = get_engine()
    ensure_schema(engine)

    run_date = date.today()

    for batch_num, tickers_batch in enumerate(chunked(TICKERS, TICKERS_PER_BATCH), start=1):
        log.info("Batch %s: %s", batch_num, tickers_batch)

        for ticker in tickers_batch:
            try:
                expirations = get_expirations(ticker)
                if not expirations:
                    log.warning("%s: no expirations returned", ticker)
                    continue

                for exp in expirations:
                    exp_date = date.fromisoformat(exp)
                    dte = (exp_date - run_date).days

                    chain = get_chain(ticker, exp)
                    if not chain:
                        log.warning("%s %s: empty chain", ticker, exp)
                        continue

                    # collect strikes found in chain (union of calls/puts)
                    strikes: set[float] = set()
                    for o in chain:
                        s = o.get("strike")
                        if s is not None:
                            strikes.add(s)

                    if not strikes:
                        log.warning("%s %s: no strikes in chain", ticker, exp)
                        continue

                    # Build OCC call+put symbols for every strike
                    call_symbols = {s: build_occ_symbol(ticker, exp, "C", s) for s in strikes}
                    put_symbols  = {s: build_occ_symbol(ticker, exp, "P", s) for s in strikes}

                    # Quote underlying + all option contracts
                    all_quote_symbols = [ticker] + list(call_symbols.values()) + list(put_symbols.values())
                    quotes_map = get_quotes_map(all_quote_symbols)

                    underlying_last = (quotes_map.get(ticker) or {}).get("last")

                    rows = []
                    for strike in strikes:
                        call_sym = call_symbols[strike]
                        put_sym = put_symbols[strike]

                        call_q = quotes_map.get(call_sym, {}) or {}
                        put_q  = quotes_map.get(put_sym, {}) or {}

                        callBid = call_q.get("bid")
                        callAsk = call_q.get("ask")
                        putBid  = put_q.get("bid")
                        putAsk  = put_q.get("ask")

                        callVol = call_q.get("volume")
                        putVol  = put_q.get("volume")

                        callMid = (callBid + callAsk) / 2 if callBid is not None and callAsk is not None else None
                        putMid  = (putBid + putAsk) / 2 if putBid is not None and putAsk is not None else None

                        itmPercCalls = (
                            ((underlying_last - strike) / strike) * 100
                            if underlying_last not in (None, 0) and strike not in (None, 0)
                            else None
                        )
                        itmPercPuts = (-itmPercCalls) if itmPercCalls is not None else None

                        rows.append({
                            "symbol": ticker,
                            "quoteDate": run_date,
                            "expireDate": exp_date,
                            "strike": strike,

                            "underlyingLast": underlying_last,

                            "callSymbol": call_sym,
                            "callVolume": callVol,
                            "callBid": callBid,
                            "callAsk": callAsk,
                            "callMid": callMid,

                            "putSymbol": put_sym,
                            "putVolume": putVol,
                            "putBid": putBid,
                            "putAsk": putAsk,
                            "putMid": putMid,

                            "itmPercCalls": itmPercCalls,
                            "itmPercPuts": itmPercPuts,
                            "dte": dte,
                        })

                    upsert_rows(engine, rows)
                    log.info("%s %s: saved %s rows", ticker, exp, len(rows))

            except Exception as e:
                log.exception("%s: failed in ticker loop: %s", ticker, e)

        time.sleep(SLEEP_BETWEEN_BATCH_SECONDS)

    log.info("EOD RUN COMPLETE")


if __name__ == "__main__":
    run_eod()

