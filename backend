import os
import time
import logging
import requests
import pandas as pd
from datetime import datetime, date

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ----------------------------
# LOGGING (VERBOSE)
# ----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger(__name__)

# ----------------------------
# CONFIG
# ----------------------------
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

TICKERS_PER_BATCH = 10
SLEEP_BETWEEN_BATCH_SECONDS = 10

HEADERS = {
    "Authorization": f"Bearer {TRADIER_TOKEN}",
    "Accept": "application/json",
}
BASE_URL = "https://api.tradier.com/v1"


# ----------------------------
# TRADIER HELPERS
# ----------------------------
def tradier_get(path: str, params: dict | None = None) -> dict:
    r = requests.get(
        f"{BASE_URL}{path}",
        headers=HEADERS,
        params=params,
        timeout=30,
    )
    r.raise_for_status()
    return r.json()


def get_expirations(ticker: str) -> list[str]:
    j = tradier_get(
        "/markets/options/expirations",
        params={"symbol": ticker, "includeAllRoots": "true"},
    )
    dates = (j.get("expirations") or {}).get("date", [])
    if isinstance(dates, str):
        dates = [dates]
    return dates


def get_chain(ticker: str, expiration: str) -> list[dict]:
    j = tradier_get(
        "/markets/options/chains",
        params={
            "symbol": ticker,
            "expiration": expiration,
            "greeks": "false",
        },
    )
    options = (j.get("options") or {}).get("option", [])
    if isinstance(options, dict):
        options = [options]
    return options


# ----------------------------
# POSTGRES
# ----------------------------
def get_engine():
    return create_engine(PG_DSN, pool_pre_ping=True)


def ensure_schema(engine):
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        quoteDate        DATE NOT NULL,
        underlyingLast   NUMERIC,
        expireDate       DATE NOT NULL,

        strike           NUMERIC NOT NULL,

        callVolume       BIGINT,
        callBid          NUMERIC,
        callAsk          NUMERIC,
        callMid          NUMERIC,

        putVolume        BIGINT,
        putBid           NUMERIC,
        putAsk           NUMERIC,
        putMid           NUMERIC,

        itmPercCalls     NUMERIC,
        itmPercPuts      NUMERIC,
        dte              INTEGER,

        PRIMARY KEY (quoteDate, expireDate, strike)
    );
    """
    with engine.begin() as conn:
        conn.execute(text(ddl))


def upsert_rows(engine, rows: list[dict]):
    if not rows:
        return

    cols = list(rows[0].keys())
    tuples = [tuple(r[c] for c in cols) for r in rows]

    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT (quoteDate, expireDate, strike)
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in cols if c not in ("quoteDate", "expireDate", "strike"))

    with engine.begin() as conn:
        raw = conn.connection
        with raw.cursor() as cur:
            execute_values(cur, sql, tuples, page_size=1000)


# ----------------------------
# UTIL
# ----------------------------
def chunked(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


# ----------------------------
# MAIN
# ----------------------------
def run_eod():
    log.info("EOD RUN START")

    engine = get_engine()
    ensure_schema(engine)

    run_date = date.today()

    for batch_num, tickers_batch in enumerate(chunked(TICKERS, TICKERS_PER_BATCH), start=1):
        log.info(f"Batch {batch_num}: {tickers_batch}")

        for ticker in tickers_batch:
            expirations = get_expirations(ticker)

            for exp in expirations:
                exp_date = date.fromisoformat(exp)
                dte = (exp_date - run_date).days

                chain = get_chain(ticker, exp)

                calls = {}
                puts = {}
                underlying = None

                for o in chain:
                    underlying = o.get("underlying_last")
                    strike = o.get("strike")

                    if o.get("option_type") == "call":
                        calls[strike] = o
                    elif o.get("option_type") == "put":
                        puts[strike] = o

                rows = []
                for strike in set(calls) | set(puts):
                    call = calls.get(strike, {})
                    put = puts.get(strike, {})

                    callBid = call.get("bid")
                    callAsk = call.get("ask")
                    putBid = put.get("bid")
                    putAsk = put.get("ask")

                    callMid = (callBid + callAsk) / 2 if callBid is not None and callAsk is not None else None
                    putMid = (putBid + putAsk) / 2 if putBid is not None and putAsk is not None else None

                    itmPercCalls = ((underlying - strike) / strike) * 100 if underlying and strike else None
                    itmPercPuts = -itmPercCalls if itmPercCalls is not None else None

                    rows.append({
                        "quoteDate": run_date,
                        "underlyingLast": underlying,
                        "expireDate": exp_date,
                        "strike": strike,

                        "callVolume": call.get("volume"),
                        "callBid": callBid,
                        "callAsk": callAsk,
                        "callMid": callMid,

                        "putVolume": put.get("volume"),
                        "putBid": putBid,
                        "putAsk": putAsk,
                        "putMid": putMid,

                        "itmPercCalls": itmPercCalls,
                        "itmPercPuts": itmPercPuts,
                        "dte": dte,
                    })

                upsert_rows(engine, rows)
                log.info(f"{ticker} {exp}: saved {len(rows)} rows")

        time.sleep(SLEEP_BETWEEN_BATCH_SECONDS)

    log.info("EOD RUN COMPLETE")


if __name__ == "__main__":
    run_eod()

