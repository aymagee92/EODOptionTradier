import os
import time
import logging
import requests
from datetime import date

from sqlalchemy import create_engine, text
from psycopg2.extras import execute_values

# ----------------------------
# LOGGING (VERBOSE)
# ----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)
log = logging.getLogger(__name__)

# ----------------------------
# CONFIG
# ----------------------------
TICKERS = ["AAPL", "MSFT", "TSLA", "AMD"]

TRADIER_TOKEN = os.environ["TRADIER_ACCESS_TOKEN"]
PG_DSN = os.environ["PG_DSN"]

TICKERS_PER_BATCH = 10
SLEEP_BETWEEN_BATCH_SECONDS = 10

# Optional override (useful if your token is sandbox)
# export TRADIER_BASE_URL=https://sandbox.tradier.com/v1
BASE_URL = os.getenv("TRADIER_BASE_URL", "https://api.tradier.com/v1")

HEADERS = {
    "Authorization": "Bearer {}".format(TRADIER_TOKEN),  # matches your working script
    "Accept": "application/json",
}

session = requests.Session()
session.headers.update(HEADERS)


# ----------------------------
# TRADIER HELPERS
# ----------------------------
def tradier_get(path: str, params: dict | None = None) -> dict:
    url = f"{BASE_URL}{path}"
    r = session.get(url, params=params, timeout=30)

    # If Tradier errors, log the body so you can see the real reason (401/403/429/etc.)
    if r.status_code >= 400:
        log.error("Tradier error %s %s params=%s body=%s", r.status_code, url, params, r.text[:2000])

    r.raise_for_status()
    return r.json()


def get_expirations(ticker: str) -> list[str]:
    # matches working script params style
    j = tradier_get(
        "/markets/options/expirations",
        params={"symbol": ticker, "includeAllRoots": "true", "strikes": "false"},
    )
    dates = (j.get("expirations") or {}).get("date", [])
    if isinstance(dates, str):
        dates = [dates]
    return dates


def get_chain(ticker: str, expiration: str) -> list[dict]:
    j = tradier_get(
        "/markets/options/chains",
        params={"symbol": ticker, "expiration": expiration, "greeks": "false"},
    )
    options = (j.get("options") or {}).get("option", [])
    if isinstance(options, dict):
        options = [options]
    if options is None:
        options = []
    return options


# ----------------------------
# POSTGRES
# ----------------------------
def get_engine():
    return create_engine(PG_DSN, pool_pre_ping=True)


def ensure_schema(engine):
    # IMPORTANT FIX: include symbol in PK so tickers don't overwrite each other
    ddl = """
    CREATE TABLE IF NOT EXISTS option_chain_eod (
        quoteDate        DATE NOT NULL,
        symbol           TEXT NOT NULL,

        underlyingLast   NUMERIC,
        expireDate       DATE NOT NULL,
        strike           NUMERIC NOT NULL,

        callVolume       BIGINT,
        callBid          NUMERIC,
        callAsk          NUMERIC,
        callMid          NUMERIC,

        putVolume        BIGINT,
        putBid           NUMERIC,
        putAsk           NUMERIC,
        putMid           NUMERIC,

        itmPercCalls     NUMERIC,
        itmPercPuts      NUMERIC,
        dte              INTEGER,

        PRIMARY KEY (quoteDate, symbol, expireDate, strike)
    );
    """
    with engine.begin() as conn:
        conn.execute(text(ddl))


def upsert_rows(engine, rows: list[dict]):
    if not rows:
        return

    cols = list(rows[0].keys())
    tuples = [tuple(r.get(c) for c in cols) for r in rows]

    conflict_cols = ("quoteDate", "symbol", "expireDate", "strike")
    update_cols = [c for c in cols if c not in conflict_cols]

    sql = f"""
    INSERT INTO option_chain_eod ({",".join(cols)})
    VALUES %s
    ON CONFLICT ({",".join(conflict_cols)})
    DO UPDATE SET
    """ + ", ".join(f"{c}=EXCLUDED.{c}" for c in update_cols)

    with engine.begin() as conn:
        raw = conn.connection
        with raw.cursor() as cur:
            execute_values(cur, sql, tuples, page_size=1000)


# ----------------------------
# UTIL
# ----------------------------
def chunked(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


# ----------------------------
# MAIN
# ----------------------------
def run_eod():
    log.info("EOD RUN START | base_url=%s", BASE_URL)

    engine = get_engine()
    ensure_schema(engine)

    run_date = date.today()

    for batch_num, tickers_batch in enumerate(chunked(TICKERS, TICKERS_PER_BATCH), start=1):
        log.info("Batch %s: %s", batch_num, tickers_batch)

        for ticker in tickers_batch:
            try:
                expirations = get_expirations(ticker)
                if not expirations:
                    log.warning("%s: no expirations returned", ticker)
                    continue

                for exp in expirations:
                    exp_date = date.fromisoformat(exp)
                    dte = (exp_date - run_date).days

                    chain = get_chain(ticker, exp)
                    if not chain:
                        # Not necessarily fatal; Tradier can return empty options sometimes
                        log.warning("%s %s: empty chain", ticker, exp)
                        continue

                    calls = {}
                    puts = {}
                    underlying = None

                    for o in chain:
                        # underlying_last sometimes repeats; just take what we see
                        if underlying is None:
                            underlying = o.get("underlying_last")

                        strike = o.get("strike")
                        if strike is None:
                            continue

                        ot = o.get("option_type")
                        if ot == "call":
                            calls[strike] = o
                        elif ot == "put":
                            puts[strike] = o

                    rows = []
                    for strike in set(calls) | set(puts):
                        call = calls.get(strike, {}) or {}
                        put = puts.get(strike, {}) or {}

                        callBid = call.get("bid")
                        callAsk = call.get("ask")
                        putBid = put.get("bid")
                        putAsk = put.get("ask")

                        callMid = (callBid + callAsk) / 2 if callBid is not None and callAsk is not None else None
                        putMid = (putBid + putAsk) / 2 if putBid is not None and putAsk is not None else None

                        itmPercCalls = ((underlying - strike) / strike) * 100 if underlying not in (None, 0) and strike not in (None, 0) else None
                        itmPercPuts = (-itmPercCalls) if itmPercCalls is not None else None

                        rows.append({
                            "quoteDate": run_date,
                            "symbol": ticker,

                            "underlyingLast": underlying,
                            "expireDate": exp_date,
                            "strike": strike,

                            "callVolume": call.get("volume"),
                            "callBid": callBid,
                            "callAsk": callAsk,
                            "callMid": callMid,

                            "putVolume": put.get("volume"),
                            "putBid": putBid,
                            "putAsk": putAsk,
                            "putMid": putMid,

                            "itmPercCalls": itmPercCalls,
                            "itmPercPuts": itmPercPuts,
                            "dte": dte,
                        })

                    upsert_rows(engine, rows)
                    log.info("%s %s: saved %s rows", ticker, exp, len(rows))

            except Exception as e:
                log.exception("%s: failed in ticker loop: %s", ticker, e)

        time.sleep(SLEEP_BETWEEN_BATCH_SECONDS)

    log.info("EOD RUN COMPLETE")


if __name__ == "__main__":
    run_eod()


